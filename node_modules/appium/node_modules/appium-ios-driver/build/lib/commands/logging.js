"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.helpers = exports.commands = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _iosLog = _interopRequireDefault(require("../device-log/ios-log"));

var _iosCrashLog = _interopRequireDefault(require("../device-log/ios-crash-log"));

var _logger = _interopRequireDefault(require("../logger"));

let commands = {},
    helpers = {},
    extensions = {};
exports.helpers = helpers;
exports.commands = commands;

extensions.extractLogs = function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (logType, logsContainer = {}) {
    if (_lodash.default.isEmpty(logsContainer)) {
      throw new Error('No logs currently available. Is the device/simulator started?');
    }

    const logObject = logsContainer[logType];
    const logs = logObject ? yield logObject.getLogs() : null;

    if (logs) {
      return logs;
    }

    throw new Error(`No logs of type '${logType}' found.`);
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

extensions.supportedLogTypes = {
  syslog: {
    description: 'System Logs - Device logs for iOS applications on real devices and simulators',
    getter: function () {
      var _getter = (0, _asyncToGenerator2.default)(function* (self) {
        return yield self.extractLogs('syslog', self.logs);
      });

      return function getter(_x2) {
        return _getter.apply(this, arguments);
      };
    }()
  },
  crashlog: {
    description: 'Crash Logs - Crash reports for iOS applications on real devices and simulators',
    getter: function () {
      var _getter2 = (0, _asyncToGenerator2.default)(function* (self) {
        return yield self.extractLogs('crashlog', self.logs);
      });

      return function getter(_x3) {
        return _getter2.apply(this, arguments);
      };
    }()
  },
  performance: {
    description: 'Performance Logs - Debug Timelines on real devices and simulators',
    getter: function () {
      var _getter3 = (0, _asyncToGenerator2.default)(function* (self) {
        return yield self.extractLogs('performance', self.logs);
      });

      return function getter(_x4) {
        return _getter3.apply(this, arguments);
      };
    }()
  },
  server: {
    description: 'Appium server logs',
    getter: self => {
      if (!self.relaxedSecurityEnabled) {
        throw new Error('Appium server must have relaxed security flag set ' + 'in order to retrieve server logs');
      }

      return _logger.default.unwrap().record.map(x => {
        return {
          timestamp: Date.now(),
          level: 'ALL',
          message: _lodash.default.isEmpty(x.prefix) ? x.message : `[${x.prefix}] ${x.message}`
        };
      });
    }
  }
};

helpers.startLogCapture = function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (sim) {
    if (!_lodash.default.isEmpty(this.logs)) {
      _logger.default.warn("Trying to start iOS log capture but it's already started!");

      return;
    }

    this.logs.crashlog = new _iosCrashLog.default();
    this.logs.syslog = new _iosLog.default({
      sim,
      udid: this.opts.udid,
      showLogs: this.opts.showIOSLog,
      realDeviceLogger: this.opts.realDeviceLogger,
      xcodeVersion: this.xcodeVersion
    });

    try {
      yield this.logs.syslog.startCapture();
    } catch (err) {
      _logger.default.warn("Could not capture logs from device. Continuing without capturing logs.");

      return;
    }

    yield this.logs.crashlog.startCapture();
  });

  return function (_x5) {
    return _ref2.apply(this, arguments);
  };
}();

Object.assign(extensions, commands, helpers);
var _default = extensions;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9sb2dnaW5nLmpzIl0sIm5hbWVzIjpbImNvbW1hbmRzIiwiaGVscGVycyIsImV4dGVuc2lvbnMiLCJleHRyYWN0TG9ncyIsImxvZ1R5cGUiLCJsb2dzQ29udGFpbmVyIiwiXyIsImlzRW1wdHkiLCJFcnJvciIsImxvZ09iamVjdCIsImxvZ3MiLCJnZXRMb2dzIiwic3VwcG9ydGVkTG9nVHlwZXMiLCJzeXNsb2ciLCJkZXNjcmlwdGlvbiIsImdldHRlciIsInNlbGYiLCJjcmFzaGxvZyIsInBlcmZvcm1hbmNlIiwic2VydmVyIiwicmVsYXhlZFNlY3VyaXR5RW5hYmxlZCIsImxvZ2dlciIsInVud3JhcCIsInJlY29yZCIsIm1hcCIsIngiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwibGV2ZWwiLCJtZXNzYWdlIiwicHJlZml4Iiwic3RhcnRMb2dDYXB0dXJlIiwic2ltIiwid2FybiIsIklPU0NyYXNoTG9nIiwiSU9TTG9nIiwidWRpZCIsIm9wdHMiLCJzaG93TG9ncyIsInNob3dJT1NMb2ciLCJyZWFsRGV2aWNlTG9nZ2VyIiwieGNvZGVWZXJzaW9uIiwic3RhcnRDYXB0dXJlIiwiZXJyIiwiT2JqZWN0IiwiYXNzaWduIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLElBQUlBLFFBQVEsR0FBRyxFQUFmO0FBQUEsSUFBbUJDLE9BQU8sR0FBRyxFQUE3QjtBQUFBLElBQWlDQyxVQUFVLEdBQUcsRUFBOUM7Ozs7QUFFQUEsVUFBVSxDQUFDQyxXQUFYO0FBQUEsNkNBQXlCLFdBQWdCQyxPQUFoQixFQUF5QkMsYUFBYSxHQUFHLEVBQXpDLEVBQTZDO0FBR3BFLFFBQUlDLGdCQUFFQyxPQUFGLENBQVVGLGFBQVYsQ0FBSixFQUE4QjtBQUM1QixZQUFNLElBQUlHLEtBQUosQ0FBVSwrREFBVixDQUFOO0FBQ0Q7O0FBR0QsVUFBTUMsU0FBUyxHQUFHSixhQUFhLENBQUNELE9BQUQsQ0FBL0I7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QUFJO0FBQ0YsWUFBTSxLQUFLaEMsSUFBTCxDQUFVRyxNQUFWLENBQWlCOEIsWUFBakIsRUFBTjtBQUNELEtBRkQsQ0FFRSxPQUFPQyxHQUFQLEVBQVk7QUFDWnZCLHNCQUFPYSxJQUFQLENBQVksd0VBQVo7O0FBQ0E7QUFDRDs7QUFDRCxVQUFNLEtBQUt4QixJQUFMLENBQVVPLFFBQVYsQ0FBbUIwQixZQUFuQixFQUFOO0FBQ0QsR0FwQkQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBdUJBRSxNQUFNLENBQUNDLE1BQVAsQ0FBYzVDLFVBQWQsRUFBMEJGLFFBQTFCLEVBQW9DQyxPQUFwQztlQUVlQyxVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBJT1NMb2cgZnJvbSAnLi4vZGV2aWNlLWxvZy9pb3MtbG9nJztcbmltcG9ydCBJT1NDcmFzaExvZyBmcm9tICcuLi9kZXZpY2UtbG9nL2lvcy1jcmFzaC1sb2cnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuLi9sb2dnZXInO1xuXG5cbmxldCBjb21tYW5kcyA9IHt9LCBoZWxwZXJzID0ge30sIGV4dGVuc2lvbnMgPSB7fTtcblxuZXh0ZW5zaW9ucy5leHRyYWN0TG9ncyA9IGFzeW5jIGZ1bmN0aW9uIChsb2dUeXBlLCBsb2dzQ29udGFpbmVyID0ge30pIHtcbiAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBsb2dzIGF0IGFsbFxuICAvLyBvdGhlcndpc2UgaXQncyBub3QgYmVlbiBpbml0aWFsaXplZFxuICBpZiAoXy5pc0VtcHR5KGxvZ3NDb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBsb2dzIGN1cnJlbnRseSBhdmFpbGFibGUuIElzIHRoZSBkZXZpY2Uvc2ltdWxhdG9yIHN0YXJ0ZWQ/Jyk7XG4gIH1cblxuICAvLyBJZiBsb2dzIGNhcHR1cmVkIHN1Y2Nlc3NmdWxseSBzZW5kIHJlc3BvbnNlIHdpdGggZGF0YSwgZWxzZSBzZW5kIGVycm9yXG4gIGNvbnN0IGxvZ09iamVjdCA9IGxvZ3NDb250YWluZXJbbG9nVHlwZV07XG4gIGNvbnN0IGxvZ3MgPSBsb2dPYmplY3QgPyBhd2FpdCBsb2dPYmplY3QuZ2V0TG9ncygpIDogbnVsbDtcbiAgaWYgKGxvZ3MpIHtcbiAgICByZXR1cm4gbG9ncztcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYE5vIGxvZ3Mgb2YgdHlwZSAnJHtsb2dUeXBlfScgZm91bmQuYCk7XG59O1xuXG5leHRlbnNpb25zLnN1cHBvcnRlZExvZ1R5cGVzID0ge1xuICBzeXNsb2c6IHtcbiAgICBkZXNjcmlwdGlvbjogJ1N5c3RlbSBMb2dzIC0gRGV2aWNlIGxvZ3MgZm9yIGlPUyBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJyxcbiAgICBnZXR0ZXI6IGFzeW5jIChzZWxmKSA9PiBhd2FpdCBzZWxmLmV4dHJhY3RMb2dzKCdzeXNsb2cnLCBzZWxmLmxvZ3MpLFxuICB9LFxuICBjcmFzaGxvZzoge1xuICAgIGRlc2NyaXB0aW9uOiAnQ3Jhc2ggTG9ncyAtIENyYXNoIHJlcG9ydHMgZm9yIGlPUyBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJyxcbiAgICBnZXR0ZXI6IGFzeW5jIChzZWxmKSA9PiBhd2FpdCBzZWxmLmV4dHJhY3RMb2dzKCdjcmFzaGxvZycsIHNlbGYubG9ncyksXG4gIH0sXG4gIHBlcmZvcm1hbmNlOiB7XG4gICAgZGVzY3JpcHRpb246ICdQZXJmb3JtYW5jZSBMb2dzIC0gRGVidWcgVGltZWxpbmVzIG9uIHJlYWwgZGV2aWNlcyBhbmQgc2ltdWxhdG9ycycsXG4gICAgZ2V0dGVyOiBhc3luYyAoc2VsZikgPT4gYXdhaXQgc2VsZi5leHRyYWN0TG9ncygncGVyZm9ybWFuY2UnLCBzZWxmLmxvZ3MpLFxuICB9LFxuICBzZXJ2ZXI6IHtcbiAgICBkZXNjcmlwdGlvbjogJ0FwcGl1bSBzZXJ2ZXIgbG9ncycsXG4gICAgZ2V0dGVyOiAoc2VsZikgPT4ge1xuICAgICAgaWYgKCFzZWxmLnJlbGF4ZWRTZWN1cml0eUVuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcHBpdW0gc2VydmVyIG11c3QgaGF2ZSByZWxheGVkIHNlY3VyaXR5IGZsYWcgc2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luIG9yZGVyIHRvIHJldHJpZXZlIHNlcnZlciBsb2dzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nZ2VyLnVud3JhcCgpLnJlY29yZFxuICAgICAgICAubWFwKCh4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIG5wbWxvZyBkb2VzIG5vdCBrZWVwIHRpbWVzdGFtcHMgaW4gdGhlIGhpc3RvcnlcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGxldmVsOiAnQUxMJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IF8uaXNFbXB0eSh4LnByZWZpeCkgPyB4Lm1lc3NhZ2UgOiBgWyR7eC5wcmVmaXh9XSAke3gubWVzc2FnZX1gLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG59O1xuXG5oZWxwZXJzLnN0YXJ0TG9nQ2FwdHVyZSA9IGFzeW5jIGZ1bmN0aW9uIChzaW0pIHtcbiAgaWYgKCFfLmlzRW1wdHkodGhpcy5sb2dzKSkge1xuICAgIGxvZ2dlci53YXJuKFwiVHJ5aW5nIHRvIHN0YXJ0IGlPUyBsb2cgY2FwdHVyZSBidXQgaXQncyBhbHJlYWR5IHN0YXJ0ZWQhXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxvZ3MuY3Jhc2hsb2cgPSBuZXcgSU9TQ3Jhc2hMb2coKTtcbiAgdGhpcy5sb2dzLnN5c2xvZyA9IG5ldyBJT1NMb2coe1xuICAgIHNpbSxcbiAgICB1ZGlkOiB0aGlzLm9wdHMudWRpZCxcbiAgICBzaG93TG9nczogdGhpcy5vcHRzLnNob3dJT1NMb2csXG4gICAgcmVhbERldmljZUxvZ2dlcjogdGhpcy5vcHRzLnJlYWxEZXZpY2VMb2dnZXIsXG4gICAgeGNvZGVWZXJzaW9uOiB0aGlzLnhjb2RlVmVyc2lvbixcbiAgfSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5sb2dzLnN5c2xvZy5zdGFydENhcHR1cmUoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJDb3VsZCBub3QgY2FwdHVyZSBsb2dzIGZyb20gZGV2aWNlLiBDb250aW51aW5nIHdpdGhvdXQgY2FwdHVyaW5nIGxvZ3MuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBhd2FpdCB0aGlzLmxvZ3MuY3Jhc2hsb2cuc3RhcnRDYXB0dXJlKCk7XG59O1xuXG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgY29tbWFuZHMsIGhlbHBlcnMpO1xuZXhwb3J0IHsgY29tbWFuZHMsIGhlbHBlcnMgfTtcbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbnM7XG4iXSwiZmlsZSI6ImxpYi9jb21tYW5kcy9sb2dnaW5nLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
