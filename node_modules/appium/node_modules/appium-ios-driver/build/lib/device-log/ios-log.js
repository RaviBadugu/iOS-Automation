"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEVICE_CONSOLE_PATH = exports.IOSLog = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

var _appiumSupport = require("appium-support");

var _teen_process = require("teen_process");

var _events = _interopRequireDefault(require("events"));

const EventEmitter = _events.default.EventEmitter;
const START_TIMEOUT = 10000;

const DEVICE_CONSOLE_PATH = _path.default.resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');

exports.DEVICE_CONSOLE_PATH = DEVICE_CONSOLE_PATH;
const SYSTEM_LOG_PATH = '/var/log/system.log';
const MAX_LOG_ENTRIES_COUNT = 10000;

class IOSLog extends EventEmitter {
  constructor(opts) {
    super();
    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;
    this.realDeviceLogger = opts.realDeviceLogger || 'idevicesyslog';
    this.xcodeVersion = opts.xcodeVersion;
    this.proc = null;
    this.logs = [];
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;
    this.maxBufferSize = MAX_LOG_ENTRIES_COUNT;
  }

  startCaptureRealDevice() {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      let cmd, args, env;

      if ((_this.realDeviceLogger || '').indexOf('idevicesyslog') !== -1) {
        _logger.default.debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');

        if (_this.realDeviceLogger.toLowerCase() === 'idevicesyslog') {
          cmd = 'idevicesyslog';

          try {
            yield _appiumSupport.fs.which('idevicesyslog');
          } catch (err) {
            throw new Error(`Unable to find system idevicesyslog: ${err.message}`);
          }
        } else {
          if (!(yield _appiumSupport.fs.exists(_this.realDeviceLogger))) {
            throw new Error(`Unable to find idevicesyslog from 'realDeviceLogger' capability '${_this.realDeviceLogger}'`);
          }

          cmd = _this.realDeviceLogger;
        }

        args = ['-u', _this.udid];
        env = process.env;
      } else if ((_this.realDeviceLogger || '').indexOf('deviceconsole') !== -1) {
        _logger.default.debug('Attempting iOS device log capture via deviceconsole');

        let deviceconsole;

        if (_this.realDeviceLogger.toLowerCase() === 'deviceconsole') {
          deviceconsole = DEVICE_CONSOLE_PATH;
        } else {
          let stat;

          try {
            stat = yield _appiumSupport.fs.stat(_this.realDeviceLogger);
          } catch (err) {
            throw new Error(`Unable to find deviceconsole from 'realDeviceLogger' capability '${_this.realDeviceLogger}': ${err.message}`);
          }

          if (stat.isDirectory()) {
            deviceconsole = _this.realDeviceLogger;
          } else {
            if (!_lodash.default.endsWith(_this.realDeviceLogger, 'deviceconsole')) {
              throw new Error(`Unable to parse 'deviceconsole' installation directory from '${_this.realDeviceLogger}'`);
            }

            deviceconsole = _path.default.dirname(_this.realDeviceLogger);
          }
        }

        _logger.default.debug(`Using 'deviceconsole' from '${deviceconsole}'`);

        cmd = `${deviceconsole}/deviceconsole`;
        args = ['-u', _this.udid];
        env = _lodash.default.clone(process.env);
        env.DYLD_LIBRARY_PATH = deviceconsole;

        if (process.env.DYLD_LIBRARY_PATH) {
          env.DYLD_LIBRARY_PATH = `${env.DYLD_LIBRARY_PATH}:${process.env.DYLD_LIBRARY_PATH}`;
        }
      } else {
        _logger.default.errorAndThrow(`Unable to capture device log. Unknown 'realDeviceLogger': '${_this.realDeviceLogger}'`);
      }

      _this.subprocessId = `${cmd}_${_this.udid}`;

      _logger.default.debug(`Starting iOS device log capture with: '${cmd}'`);

      try {
        yield _this.killExistingSysLogProcesses(cmd, args);
      } catch (e) {}

      _this.proc = _this.getIDeviceSysLogProcess(cmd, args, env);
      yield _this.finishStartingLogCapture();
    })();
  }

  startCaptureSimulator() {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      _logger.default.debug(`Starting iOS ${yield _this2.sim.getPlatformVersion()} simulator log capture`);

      if (_this2.xcodeVersion.major < 5) {
        _this2.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
        yield _this2.finishStartingLogCapture();
        return;
      }

      if (_lodash.default.isUndefined(_this2.sim.udid)) {
        _logger.default.errorAndThrow(`iOS log capture with Xcode ${_this2.xcodeVersion.versionString} requires a sim udid`);
      }

      let logPath = _this2.sim.getLogDir();

      try {
        if (logPath.indexOf('*') >= 0) {
          _logger.default.error(`Log path has * in it. Unable to start log capture: ${logPath}`);

          return;
        }

        let systemLogPath = _path.default.resolve(logPath, 'system.log');

        _logger.default.debug(`System log path: ${systemLogPath}`);

        yield (0, _appiumSupport.mkdirp)(logPath);
        yield _appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', {
          flag: 'a'
        });
        let files;

        try {
          files = yield _appiumSupport.fs.glob(systemLogPath);

          if (files.length < 1) {
            throw new Error('Could not start log capture');
          }
        } catch (e) {
          _logger.default.error(`Could not start log capture because no iOS ` + `simulator logs could be found at ${systemLogPath}. ` + `Logging will not be functional for this run`);
        }

        let lastModifiedLogPath = files[0];
        let lastModifiedLogTime = (yield _appiumSupport.fs.stat(lastModifiedLogPath)).mtime;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            let file = _step.value;

            let _ref = yield _appiumSupport.fs.stat(file),
                mtime = _ref.mtime;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        const tailArgs = ['-f', '-n', '1', lastModifiedLogPath];

        try {
          yield (0, _teen_process.exec)('pkill', ['-xf', ['tail', ...tailArgs].join(' ')]);
        } catch (e) {}

        _this2.proc = new _teen_process.SubProcess('tail', tailArgs);
        yield _this2.finishStartingLogCapture();
      } catch (err) {
        _logger.default.errorAndThrow(`Simulator log capture failed: ${err.message}`);
      }
    })();
  }

  startCapture() {
    var _this3 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this3.udid) {
        return yield _this3.startCaptureRealDevice();
      }

      return yield _this3.startCaptureSimulator();
    })();
  }

  finishStartingLogCapture() {
    var _this4 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (!_this4.proc) {
        _logger.default.errorAndThrow('Could not capture device log');
      }

      let firstLine = true;

      _this4.proc.on('output', (stdout, stderr) => {
        if (stdout) {
          if (firstLine) {
            if (stdout.substr(-1, 1) === '\n') {
              firstLine = false;
            }
          } else {
            _this4.logRow += stdout;

            if (stdout.substr(-1, 1) === '\n') {
              _this4.onOutput();

              _this4.logRow = '';
            }
          }
        }

        if (stderr) {
          _this4.onOutput('STDERR');
        }
      });

      let sd = (stdout, stderr) => {
        if (/execvp\(\)/.test(stderr)) {
          throw new Error('iOS log capture process failed to start');
        }

        return stdout || stderr;
      };

      yield _this4.proc.start(sd, START_TIMEOUT);
    })();
  }

  stopCapture() {
    var _this5 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this5.proc) {
        if (_this5.udid) {
          const cachedSysLog = IOSLog.cachedIDeviceSysLogs[_this5.subprocessId];

          if (cachedSysLog) {
            cachedSysLog.count--;

            if (cachedSysLog.count === 0) {
              yield _this5.killLogSubProcess();
              delete IOSLog.cachedIDeviceSysLogs[_this5.subprocessId];
            }
          }
        } else {
          yield _this5.killLogSubProcess();
        }
      }

      _this5.proc = null;
    })();
  }

  killLogSubProcess() {
    var _this6 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this6.proc.isRunning) {
        _logger.default.debug('Stopping iOS log capture');

        try {
          yield _this6.proc.stop('SIGTERM', 1000);
        } catch (e) {
          _logger.default.error('Cannot stop log capture process. Sending SIGKILL...');

          yield _this6.proc.stop('SIGKILL');
        }
      }
    })();
  }

  onOutput(prefix = '') {
    let logs = this.logRow.split('\n');
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = logs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let log = _step2.value;
        if (!log) continue;
        let logObj = {
          timestamp: Date.now(),
          level: 'ALL',
          message: log
        };
        this.logs.push(logObj);
        this.emit('output', logObj);

        if (this.logs.length > this.maxBufferSize) {
          this.logs.shift();

          if (this.logIdxSinceLastRequest > 0) {
            --this.logIdxSinceLastRequest;
          }
        }

        if (this.showLogs) {
          let space = prefix.length > 0 ? ' ' : '';

          _logger.default.info(`[IOS_SYSLOG_ROW${space}${prefix}] ${log}`);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  getLogs() {
    var _this7 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this7.logs.length && _this7.logIdxSinceLastRequest < _this7.logs.length) {
        let result = _this7.logs;

        if (_this7.logIdxSinceLastRequest > 0) {
          result = result.slice(_this7.logIdxSinceLastRequest);
        }

        _this7.logIdxSinceLastRequest = _this7.logs.length;
        return result;
      }

      return [];
    })();
  }

  getAllLogs() {
    var _this8 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      return _this8.logs;
    })();
  }

  killExistingSysLogProcesses(cmd, args) {
    var _this9 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (!IOSLog.cachedIDeviceSysLogs[_this9.subprocessId]) {
        yield (0, _teen_process.exec)('pkill', ['-xf', [cmd, ...args].join(' ')]);
      }
    })();
  }

  getIDeviceSysLogProcess(cmd, args, env) {
    if (!IOSLog.cachedIDeviceSysLogs[this.subprocessId]) {
      let _IOSLog$cachedIDevice = IOSLog.cachedIDeviceSysLogs[this.subprocessId] = {
        proc: new _teen_process.SubProcess(cmd, args, {
          env
        }),
        count: 1
      },
          proc = _IOSLog$cachedIDevice.proc;

      proc.on('exit', () => delete IOSLog.cachedIDeviceSysLogs[this.subprocessId]);
    } else {
      IOSLog.cachedIDeviceSysLogs[this.subprocessId].count++;
    }

    return IOSLog.cachedIDeviceSysLogs[this.subprocessId].proc;
  }

}

exports.IOSLog = IOSLog;
IOSLog.cachedIDeviceSysLogs = {};
var _default = IOSLog;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiZXZlbnRzIiwiU1RBUlRfVElNRU9VVCIsIkRFVklDRV9DT05TT0xFX1BBVEgiLCJwYXRoIiwicmVzb2x2ZSIsIl9fZGlybmFtZSIsIlNZU1RFTV9MT0dfUEFUSCIsIk1BWF9MT0dfRU5UUklFU19DT1VOVCIsIklPU0xvZyIsImNvbnN0cnVjdG9yIiwib3B0cyIsInNpbSIsInVkaWQiLCJzaG93TG9ncyIsInJlYWxEZXZpY2VMb2dnZXIiLCJ4Y29kZVZlcnNpb24iLCJwcm9jIiwibG9ncyIsImxvZ1JvdyIsImxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QiLCJtYXhCdWZmZXJTaXplIiwic3RhcnRDYXB0dXJlUmVhbERldmljZSIsImNtZCIsImFyZ3MiLCJlbnYiLCJpbmRleE9mIiwibG9nZ2VyIiwiZGVidWciLCJ0b0xvd2VyQ2FzZSIsImZzIiwid2hpY2giLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJleGlzdHMiLCJwcm9jZXNzIiwiZGV2aWNlY29uc29sZSIsInN0YXQiLCJpc0RpcmVjdG9yeSIsIl8iLCJlbmRzV2l0aCIsImRpcm5hbWUiLCJjbG9uZSIsIkRZTERfTElCUkFSWV9QQVRIIiwiZXJyb3JBbmRUaHJvdyIsInN1YnByb2Nlc3NJZCIsImtpbGxFeGlzdGluZ1N5c0xvZ1Byb2Nlc3NlcyIsImUiLCJnZXRJRGV2aWNlU3lzTG9nUHJvY2VzcyIsImZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSIsInN0YXJ0Q2FwdHVyZVNpbXVsYXRvciIsImdldFBsYXRmb3JtVmVyc2lvbiIsIm1ham9yIiwiU3ViUHJvY2VzcyIsImlzVW5kZWZpbmVkIiwidmVyc2lvblN0cmluZyIsImxvZ1BhdGgiLCJnZXRMb2dEaXIiLCJlcnJvciIsInN5c3RlbUxvZ1BhdGgiLCJ3cml0ZUZpbGUiLCJmbGFnIiwiZmlsZXMiLCJnbG9iIiwibGVuZ3RoIiwibGFzdE1vZGlmaWVkTG9nUGF0aCIsImxhc3RNb2RpZmllZExvZ1RpbWUiLCJtdGltZSIsImZpbGUiLCJ0YWlsQXJncyIsImpvaW4iLCJzdGFydENhcHR1cmUiLCJmaXJzdExpbmUiLCJvbiIsInN0ZG91dCIsInN0ZGVyciIsInN1YnN0ciIsIm9uT3V0cHV0Iiwic2QiLCJ0ZXN0Iiwic3RhcnQiLCJzdG9wQ2FwdHVyZSIsImNhY2hlZFN5c0xvZyIsImNhY2hlZElEZXZpY2VTeXNMb2dzIiwiY291bnQiLCJraWxsTG9nU3ViUHJvY2VzcyIsImlzUnVubmluZyIsInN0b3AiLCJwcmVmaXgiLCJzcGxpdCIsImxvZyIsImxvZ09iaiIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJsZXZlbCIsInB1c2giLCJlbWl0Iiwic2hpZnQiLCJzcGFjZSIsImluZm8iLCJnZXRMb2dzIiwicmVzdWx0Iiwic2xpY2UiLCJnZXRBbGxMb2dzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztNQUNRQSxZLEdBQWlCQyxlLENBQWpCRCxZO0FBRVIsTUFBTUUsYUFBYSxHQUFHLEtBQXRCOztBQUNBLE1BQU1DLG1CQUFtQixHQUFHQyxjQUFLQyxPQUFMLENBQWFDLFNBQWIsRUFBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEMsRUFBMEMsT0FBMUMsRUFBbUQsZUFBbkQsQ0FBNUI7OztBQUNBLE1BQU1DLGVBQWUsR0FBRyxxQkFBeEI7QUFFQSxNQUFNQyxxQkFBcUIsR0FBRyxLQUE5Qjs7QUFFQSxNQUFNQyxNQUFOLFNBQXFCVCxZQUFyQixDQUFrQztBQUNoQ1UsRUFBQUEsV0FBVyxDQUFFQyxJQUFGLEVBQVE7QUFDakI7QUFDQSxTQUFLQyxHQUFMLEdBQVdELElBQUksQ0FBQ0MsR0FBaEI7QUFDQSxTQUFLQyxJQUFMLEdBQVlGLElBQUksQ0FBQ0UsSUFBakI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLENBQUMsQ0FBQ0gsSUFBSSxDQUFDRyxRQUF2QjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdC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ZCxDQUFOO0FBQ0Q7QUFIMkM7QUFJN0M7O0FBUUR0QixFQUFBQSx1QkFBdUIsQ0FBRTFCLEdBQUYsRUFBT0MsSUFBUCxFQUFhQyxHQUFiLEVBQWtCO0FBQ3ZDLFFBQUksQ0FBQ2hCLE1BQU0sQ0FBQzJFLG9CQUFQLENBQTRCLEtBQUt0QyxZQUFqQyxDQUFMLEVBQXFEO0FBQUEsa0NBQ3RDckMsTUFBTSxDQUFDMkUsb0JBQVAsQ0FBNEIsS0FBS3RDLFlBQWpDLElBQWlEO0FBQzVEN0IsUUFBQUEsSUFBSSxFQUFFLElBQUlxQyx3QkFBSixDQUFlL0IsR0FBZixFQUFvQkMsSUFBcEIsRUFBMEI7QUFBQ0MsVUFBQUE7QUFBRCxTQUExQixDQURzRDtBQUU1RDRELFFBQUFBLEtBQUssRUFBRTtBQUZxRCxPQURYO0FBQUEsVUFDOUNwRSxJQUQ4Qyx5QkFDOUNBLElBRDhDOztBQU1uREEsTUFBQUEsSUFBSSxDQUFDeUQsRUFBTCxDQUFRLE1BQVIsRUFBZ0IsTUFBTSxPQUFPakUsTUFBTSxDQUFDMkUsb0JBQVAsQ0FBNEIsS0FBS3RDLFlBQWpDLENBQTdCO0FBQ0QsS0FQRCxNQU9PO0FBQ0xyQyxNQUFBQSxNQUFNLENBQUMyRSxvQkFBUCxDQUE0QixLQUFLdEMsWUFBakMsRUFBK0N1QyxLQUEvQztBQUNEOztBQUNELFdBQU81RSxNQUFNLENBQUMyRSxvQkFBUCxDQUE0QixLQUFLdEMsWUFBakMsRUFBK0M3QixJQUF0RDtBQUNEOztBQWhTK0I7OztBQW1TbENSLE1BQU0sQ0FBQzJFLG9CQUFQLEdBQThCLEVBQTlCO2VBR2UzRSxNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmcywgbWtkaXJwIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gZXZlbnRzO1xuXG5jb25zdCBTVEFSVF9USU1FT1VUID0gMTAwMDA7XG5jb25zdCBERVZJQ0VfQ09OU09MRV9QQVRIID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJywgJ2J1aWxkJywgJ2RldmljZWNvbnNvbGUnKTtcbmNvbnN0IFNZU1RFTV9MT0dfUEFUSCA9ICcvdmFyL2xvZy9zeXN0ZW0ubG9nJztcbi8vIFdlIGtlZXAgb25seSB0aGUgbW9zdCByZWNlbnQgbG9nIGVudHJpZXMgdG8gYXZvaWQgb3V0IG9mIG1lbW9yeSBlcnJvclxuY29uc3QgTUFYX0xPR19FTlRSSUVTX0NPVU5UID0gMTAwMDA7XG5cbmNsYXNzIElPU0xvZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNpbSA9IG9wdHMuc2ltO1xuICAgIHRoaXMudWRpZCA9IG9wdHMudWRpZDtcbiAgICB0aGlzLnNob3dMb2dzID0gISFvcHRzLnNob3dMb2dzO1xuICAgIHRoaXMucmVhbERldmljZUxvZ2dlciA9IG9wdHMucmVhbERldmljZUxvZ2dlciB8fCAnaWRldmljZXN5c2xvZyc7XG4gICAgdGhpcy54Y29kZVZlcnNpb24gPSBvcHRzLnhjb2RlVmVyc2lvbjtcblxuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSAtMTtcbiAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBNQVhfTE9HX0VOVFJJRVNfQ09VTlQ7XG4gIH1cblxuICBhc3luYyBzdGFydENhcHR1cmVSZWFsRGV2aWNlICgpIHtcbiAgICBsZXQgY21kLCBhcmdzLCBlbnY7XG4gICAgaWYgKCh0aGlzLnJlYWxEZXZpY2VMb2dnZXIgfHwgJycpLmluZGV4T2YoJ2lkZXZpY2VzeXNsb2cnKSAhPT0gLTEpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQXR0ZW1wdGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHZpYSBsaWJpbW9iaWxlZGV2aWNlIGlkZXZpY2VzeXNsb2cnKTtcbiAgICAgIGlmICh0aGlzLnJlYWxEZXZpY2VMb2dnZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2lkZXZpY2VzeXNsb2cnKSB7XG4gICAgICAgIGNtZCA9ICdpZGV2aWNlc3lzbG9nJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgaXQgaXMgYXZhaWxhYmxlIG9uIHRoZSBQQVRIXG4gICAgICAgICAgYXdhaXQgZnMud2hpY2goJ2lkZXZpY2VzeXNsb2cnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBzeXN0ZW0gaWRldmljZXN5c2xvZzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBleGVjdXRhYmxlIGV4aXN0c1xuICAgICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLnJlYWxEZXZpY2VMb2dnZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBpZGV2aWNlc3lzbG9nIGZyb20gJ3JlYWxEZXZpY2VMb2dnZXInIGNhcGFiaWxpdHkgJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBjbWQgPSB0aGlzLnJlYWxEZXZpY2VMb2dnZXI7XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgPSBbJy11JywgdGhpcy51ZGlkXTtcbiAgICAgIGVudiA9IHByb2Nlc3MuZW52O1xuICAgIH0gZWxzZSBpZiAoKHRoaXMucmVhbERldmljZUxvZ2dlciB8fCAnJykuaW5kZXhPZignZGV2aWNlY29uc29sZScpICE9PSAtMSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdBdHRlbXB0aW5nIGlPUyBkZXZpY2UgbG9nIGNhcHR1cmUgdmlhIGRldmljZWNvbnNvbGUnKTtcbiAgICAgIGxldCBkZXZpY2Vjb25zb2xlO1xuICAgICAgaWYgKHRoaXMucmVhbERldmljZUxvZ2dlci50b0xvd2VyQ2FzZSgpID09PSAnZGV2aWNlY29uc29sZScpIHtcbiAgICAgICAgZGV2aWNlY29uc29sZSA9IERFVklDRV9DT05TT0xFX1BBVEg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnksXG4gICAgICAgIC8vIG5vdCB0aGUgYWN0dWFsIGV4ZWN1dGFibGVcbiAgICAgICAgbGV0IHN0YXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdCA9IGF3YWl0IGZzLnN0YXQodGhpcy5yZWFsRGV2aWNlTG9nZ2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBkZXZpY2Vjb25zb2xlIGZyb20gJ3JlYWxEZXZpY2VMb2dnZXInIGNhcGFiaWxpdHkgJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGRldmljZWNvbnNvbGUgPSB0aGlzLnJlYWxEZXZpY2VMb2dnZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkndmUgcGFzc2VkIGluIGBkZXZpY2Vjb25zb2xlYCBhbmQgbm90IHNvbWV0aGluZyByYW5kb21cbiAgICAgICAgICBpZiAoIV8uZW5kc1dpdGgodGhpcy5yZWFsRGV2aWNlTG9nZ2VyLCAnZGV2aWNlY29uc29sZScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSAnZGV2aWNlY29uc29sZScgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSBmcm9tICcke3RoaXMucmVhbERldmljZUxvZ2dlcn0nYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZXhlY3V0YWJsZSwgYW5kIHRyYWlsaW5nIGAvYCwgdG8gZ2V0IHRoZSBpbnN0YWxsIGRpcmVjdG9yeVxuICAgICAgICAgIGRldmljZWNvbnNvbGUgPSBwYXRoLmRpcm5hbWUodGhpcy5yZWFsRGV2aWNlTG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVidWcoYFVzaW5nICdkZXZpY2Vjb25zb2xlJyBmcm9tICcke2RldmljZWNvbnNvbGV9J2ApO1xuXG4gICAgICBjbWQgPSBgJHtkZXZpY2Vjb25zb2xlfS9kZXZpY2Vjb25zb2xlYDtcbiAgICAgIGFyZ3MgPSBbJy11JywgdGhpcy51ZGlkXTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBlbnZpcm9ubWVudCB0byBiZSBhYmxlIHRvIHJ1biBkZXZpY2Vjb25zb2xlXG4gICAgICBlbnYgPSBfLmNsb25lKHByb2Nlc3MuZW52KTtcbiAgICAgIGVudi5EWUxEX0xJQlJBUllfUEFUSCA9IGRldmljZWNvbnNvbGU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuRFlMRF9MSUJSQVJZX1BBVEgpIHtcbiAgICAgICAgZW52LkRZTERfTElCUkFSWV9QQVRIID0gYCR7ZW52LkRZTERfTElCUkFSWV9QQVRIfToke3Byb2Nlc3MuZW52LkRZTERfTElCUkFSWV9QQVRIfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBVbmFibGUgdG8gY2FwdHVyZSBkZXZpY2UgbG9nLiBVbmtub3duICdyZWFsRGV2aWNlTG9nZ2VyJzogJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSdgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnByb2Nlc3NJZCA9IGAke2NtZH1fJHt0aGlzLnVkaWR9YDtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgaU9TIGRldmljZSBsb2cgY2FwdHVyZSB3aXRoOiAnJHtjbWR9J2ApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGNsZWFudXAgZXhpc3RpbmcgbGlzdGVuZXJzIGlmIHRoZSBwcmV2aW91cyBzZXNzaW9uIGhhcyBub3QgYmVlbiB0ZXJtaW5hdGVkIHByb3Blcmx5XG4gICAgICBhd2FpdCB0aGlzLmtpbGxFeGlzdGluZ1N5c0xvZ1Byb2Nlc3NlcyhjbWQsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBqdXN0IHVzZSBvbmUgaW5zdGFuY2Ugb2YgJ2lkZXZpY2VzeXNsb2cnIHBlciB1ZGlkXG4gICAgdGhpcy5wcm9jID0gdGhpcy5nZXRJRGV2aWNlU3lzTG9nUHJvY2VzcyhjbWQsIGFyZ3MsIGVudik7XG5cbiAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlU2ltdWxhdG9yICgpIHtcbiAgICAvLyBvdGhlcndpc2UsIGlmIHdlIGhhdmUgYSBzaW11bGF0b3IuLi5cbiAgICBsb2dnZXIuZGVidWcoYFN0YXJ0aW5nIGlPUyAke2F3YWl0IHRoaXMuc2ltLmdldFBsYXRmb3JtVmVyc2lvbigpfSBzaW11bGF0b3IgbG9nIGNhcHR1cmVgKTtcbiAgICBpZiAodGhpcy54Y29kZVZlcnNpb24ubWFqb3IgPCA1KSB7XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcygndGFpbCcsIFsnLWYnLCAnLW4nLCAnMScsIFNZU1RFTV9MT0dfUEFUSF0pO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHhjb2RlIDYrXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5zaW0udWRpZCkpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBpT1MgbG9nIGNhcHR1cmUgd2l0aCBYY29kZSAke3RoaXMueGNvZGVWZXJzaW9uLnZlcnNpb25TdHJpbmd9IHJlcXVpcmVzIGEgc2ltIHVkaWRgKTtcbiAgICB9XG5cbiAgICBsZXQgbG9nUGF0aCA9IHRoaXMuc2ltLmdldExvZ0RpcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAobG9nUGF0aC5pbmRleE9mKCcqJykgPj0gMCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYExvZyBwYXRoIGhhcyAqIGluIGl0LiBVbmFibGUgdG8gc3RhcnQgbG9nIGNhcHR1cmU6ICR7bG9nUGF0aH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN5c3RlbUxvZ1BhdGggPSBwYXRoLnJlc29sdmUobG9nUGF0aCwgJ3N5c3RlbS5sb2cnKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgU3lzdGVtIGxvZyBwYXRoOiAke3N5c3RlbUxvZ1BhdGh9YCk7XG4gICAgICBhd2FpdCBta2RpcnAobG9nUGF0aCk7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3lzdGVtTG9nUGF0aCwgJ0EgbmV3IEFwcGl1bSBzZXNzaW9uIGlzIGFib3V0IHRvIHN0YXJ0IVxcbicsIHtmbGFnOiAnYSd9KTtcbiAgICAgIGxldCBmaWxlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVzID0gYXdhaXQgZnMuZ2xvYihzeXN0ZW1Mb2dQYXRoKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzdGFydCBsb2cgY2FwdHVyZScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IHN0YXJ0IGxvZyBjYXB0dXJlIGJlY2F1c2Ugbm8gaU9TIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYHNpbXVsYXRvciBsb2dzIGNvdWxkIGJlIGZvdW5kIGF0ICR7c3lzdGVtTG9nUGF0aH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgYExvZ2dpbmcgd2lsbCBub3QgYmUgZnVuY3Rpb25hbCBmb3IgdGhpcyBydW5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhc3RNb2RpZmllZExvZ1BhdGggPSBmaWxlc1swXTtcbiAgICAgIGxldCBsYXN0TW9kaWZpZWRMb2dUaW1lID0gKGF3YWl0IGZzLnN0YXQobGFzdE1vZGlmaWVkTG9nUGF0aCkpLm10aW1lO1xuICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBsZXQge210aW1lfSA9IGF3YWl0IGZzLnN0YXQoZmlsZSk7XG4gICAgICAgIGlmIChtdGltZSA+IGxhc3RNb2RpZmllZExvZ1RpbWUpIHtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dQYXRoID0gZmlsZTtcbiAgICAgICAgICBsYXN0TW9kaWZpZWRMb2dUaW1lID0gbXRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxBcmdzID0gWyctZicsICctbicsICcxJywgbGFzdE1vZGlmaWVkTG9nUGF0aF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIGxpc3RlbmVycyBpZiB0aGUgcHJldmlvdXMgc2Vzc2lvbiBoYXMgbm90IGJlZW4gdGVybWluYXRlZCBwcm9wZXJseVxuICAgICAgICBhd2FpdCBleGVjKCdwa2lsbCcsIFsnLXhmJywgWyd0YWlsJywgLi4udGFpbEFyZ3NdLmpvaW4oJyAnKV0pO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgdGFpbEFyZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBTaW11bGF0b3IgbG9nIGNhcHR1cmUgZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZSAoKSB7XG4gICAgaWYgKHRoaXMudWRpZCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlYWwgZGV2aWNlXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydENhcHR1cmVSZWFsRGV2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0Q2FwdHVyZVNpbXVsYXRvcigpO1xuICB9XG5cbiAgYXN5bmMgZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvYykge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coJ0NvdWxkIG5vdCBjYXB0dXJlIGRldmljZSBsb2cnKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0TGluZSA9IHRydWU7XG4gICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgaWYgKGZpcnN0TGluZSkge1xuICAgICAgICAgIGlmIChzdGRvdXQuc3Vic3RyKC0xLCAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHN0b3JlIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBsb2cgYmVjYXVzZSBpdCBjYW1lIGJlZm9yZSB0aGUgc2ltIG9yIGRldmljZSB3YXMgbGF1bmNoZWRcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ1JvdyArPSBzdGRvdXQ7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dSb3cgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgdGhpcy5vbk91dHB1dCgnU1RERVJSJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgc2QgPSAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgIGlmICgvZXhlY3ZwXFwoXFwpLy50ZXN0KHN0ZGVycikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpT1MgbG9nIGNhcHR1cmUgcHJvY2VzcyBmYWlsZWQgdG8gc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGRvdXQgfHwgc3RkZXJyO1xuICAgIH07XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHNkLCBTVEFSVF9USU1FT1VUKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3BDYXB0dXJlICgpIHtcbiAgICBpZiAodGhpcy5wcm9jKSB7XG4gICAgICBpZiAodGhpcy51ZGlkKSB7XG4gICAgICAgIC8vIElmIG5vIG90aGVyIFVESUQncyBhcmUgdXNpbmcgJ2lkZXZpY2VzeXNsb2cnIGtpbGwgaXRcbiAgICAgICAgY29uc3QgY2FjaGVkU3lzTG9nID0gSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXTtcbiAgICAgICAgaWYgKGNhY2hlZFN5c0xvZykge1xuICAgICAgICAgIGNhY2hlZFN5c0xvZy5jb3VudC0tO1xuICAgICAgICAgIGlmIChjYWNoZWRTeXNMb2cuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMua2lsbExvZ1N1YlByb2Nlc3MoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5raWxsTG9nU3ViUHJvY2VzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMga2lsbExvZ1N1YlByb2Nlc3MgKCkge1xuICAgIGlmICh0aGlzLnByb2MuaXNSdW5uaW5nKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1N0b3BwaW5nIGlPUyBsb2cgY2FwdHVyZScpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAxMDAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3Qgc3RvcCBsb2cgY2FwdHVyZSBwcm9jZXNzLiBTZW5kaW5nIFNJR0tJTEwuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk91dHB1dCAocHJlZml4ID0gJycpIHtcbiAgICBsZXQgbG9ncyA9IHRoaXMubG9nUm93LnNwbGl0KCdcXG4nKTtcbiAgICBmb3IgKGxldCBsb2cgb2YgbG9ncykge1xuICAgICAgaWYgKCFsb2cpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgICBsZXQgbG9nT2JqID0ge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGxldmVsOiAnQUxMJyxcbiAgICAgICAgbWVzc2FnZTogbG9nXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dzLnB1c2gobG9nT2JqKTtcbiAgICAgIHRoaXMuZW1pdCgnb3V0cHV0JywgbG9nT2JqKTtcbiAgICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gdGhpcy5tYXhCdWZmZXJTaXplKSB7XG4gICAgICAgIHRoaXMubG9ncy5zaGlmdCgpO1xuICAgICAgICBpZiAodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID4gMCkge1xuICAgICAgICAgIC0tdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG93TG9ncykge1xuICAgICAgICBsZXQgc3BhY2UgPSBwcmVmaXgubGVuZ3RoID4gMCA/ICcgJyA6ICcnO1xuICAgICAgICBsb2dnZXIuaW5mbyhgW0lPU19TWVNMT0dfUk9XJHtzcGFjZX0ke3ByZWZpeH1dICR7bG9nfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldExvZ3MgKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCAmJiB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLmxvZ3MubGVuZ3RoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5sb2dzO1xuICAgICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSB0aGlzLmxvZ3MubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsTG9ncyAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIHJldHVybiB0aGlzLmxvZ3M7XG4gIH1cblxuICBhc3luYyBraWxsRXhpc3RpbmdTeXNMb2dQcm9jZXNzZXMgKGNtZCwgYXJncykge1xuICAgIGlmICghSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXSkge1xuICAgICAgYXdhaXQgZXhlYygncGtpbGwnLCBbJy14ZicsIFtjbWQsIC4uLmFyZ3NdLmpvaW4oJyAnKV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgJ2lkZXZpY2VzeXNsb2cnIHN1YnByb2Nlc3MgZm9yIGEgZ2l2ZW4gdWRpZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYW5kIHJlLXVzZXMgaW5zdGFuY2VzIHNvIHRoYXQgdGhlcmUnc1xuICAgKiBqdXN0IG9uZSBpbnN0YW5jZSBwZXIgZGV2aWNlIChjYWNoZSBieSBVRElEKVxuICAgKi9cbiAgZ2V0SURldmljZVN5c0xvZ1Byb2Nlc3MgKGNtZCwgYXJncywgZW52KSB7XG4gICAgaWYgKCFJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdKSB7XG4gICAgICBsZXQge3Byb2N9ID0gSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXSA9IHtcbiAgICAgICAgcHJvYzogbmV3IFN1YlByb2Nlc3MoY21kLCBhcmdzLCB7ZW52fSksXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfTtcbiAgICAgIC8vIElmIHRoZSBwcm9jZXNzIGRpZXMsIHJlbW92ZSBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgcHJvYy5vbignZXhpdCcsICgpID0+IGRlbGV0ZSBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXS5jb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXS5wcm9jO1xuICB9XG59XG5cbklPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9ncyA9IHt9O1xuXG5leHBvcnQgeyBJT1NMb2csIERFVklDRV9DT05TT0xFX1BBVEggfTtcbmV4cG9ydCBkZWZhdWx0IElPU0xvZztcbiJdLCJmaWxlIjoibGliL2RldmljZS1sb2cvaW9zLWxvZy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
